\newpage
\section{Design patterns\label{design_pattern}}

Da der foreligger et krav om at vores system skal være modulært og udvidelsesvenligt, er det nærliggende at se på om vi kan indkorporere design patterns i systemarkitekturen. Design patterns går ud på at genkende mønstre i udviklingsfasen og så lave en løsning som er så generel at den kan genbruges næste gang vi støder på dette mønster. 

Der findes mange forskellige design patterns som tager sig af forskellige problemområder, 
på forskellige måder. Man kan bruge disse forskellige måder at tackle problemer og/eller opgaver på, til at kategorisere design patterns i 3 kategorier. De konstruerende, de strukturelle og de handlingsorienterede patterns.

De konstruerende patterns omhandler hvordan man opretter objekter. De strukturelle patterns tager sig af arkitekturen i designet. De handlende patterns fokuserer på hvordan man behandler objekter og hvordan man designer fremtidssikrede applikationer med videre.

Design patterns giver flere fordele:
\begin{itemize}
\item Genbrugbarhed af gode løsninger.
\item Skaber fælles forståelse og kommunikation mellem udviklere.
\item At tænke problemløsning på et højere og mere abstrakt plan.
\item Til at beslutte om vi har det rigtige design eller blot et der virker.
\item Gør koden nemmere at ændre.
\item Gør designet mere modulært.
\item Gør koden mere flexibel.
\item Gør kode og design mere elegant.
\end{itemize}

\subsection{Model View Controller\label{MVC}}
Vi vil i dette projekt kigge nærmere på det design pattern der hedder MVC\footnote{Model View Controller}. Formålet med dette pattern er at dele et systems ansvarsområder op i tre dele, på en sådan måde at de tre dele bliver uafhængige af hinanden. Det er her, når det kommer til udvidelsesvenlighed, at MVC bliver brugbart. Det er modellagets ansvar at styre behandling af data, databaseadgang og forretningslogik. Det data der bliver sendt fra modellaget skal være brugergrænseflade uafhængigt, hvorved så mange forskellige views som mulig kan bruge modellen. Kontrollaget har ansvaret for at reagere på forandringer i brugergrænsefladen (input fra brugeren). Kontrollaget giver modellaget besked om at den skal ændre sig og giver besked til view om at der er sket ændringer i modellen, sådan at view skal opdatere sig. Det er viewlagets ansvar at præsentere data for brugeren, det vil sige at view står for alt hvad der har at gøre med 'look and feel'. Med 'look and feel' menes at det er view der står for at formatere data inden det præsenteres for brugeren.

Der er to måder at anskue MVC på, hvor den ene er en aktiv model og den anden er en passiv model. I den passive model ændrer modellaget sig kun når kontrollaget giver besked om det. Dette medfører at modellaget har lav kobling med view og kontrol, hvilket betyder at modellaget ikke ved at de eksisterer. I den aktive model er der andre end view og kontrol som kan ændre modellaget, dette kunne være andre modellag, hvilket gør at modellaget bliver nødt til at give bedsked til view om at den har ændret sig. I dette tilfælde er det nærliggende at gøre brug af at et andet design pattern, nemlig Observer, også kaldet Subscriber/Publisher. Ideen er at view tilmelder sig de modeller de gerne vil have besked fra når der sker ændringer i dem. Modellaget giver dermed besked til alle på listen og viewlaget kan nu hente de nye data. 

Hele formålet med design patterns er at generalisere sine løsninger og derigennem at kunne genbruge sin kode og de erfaringer man har med at bygge arkitektureren. Der er ingen grund til at skulle opfinde den dybe tallerken for hver gang man skal strukturere et system. 

Det vi vil opnå med MVC er at gøre vores system udvidelsesvenligt. Det smarte er at vi kan ændre forretningslogikken uden at skulle ændre i kontrol og viewlaget.

Et eksempel på brugen af MVC.

\lstset{language=[Sharp]C, % fortæller hvilket sprog koden er skrevet i [dialekt].
  basicstyle=\small, breaklines=true}

\begin{lstlisting}
public partial class KundeData : Form
{
  KundeKontrol kundeKontrol = new KundeKontrol();
  Session session = new Session();

  private void rdoPerson1_CheckedChanged(object sender, EventArgs e)
  {
     kundeKontrol.getEvent(sender);
  }

  public void VisKunde(Kunde k)
  {
    Kunde k = session.GetKundeKontainer().GetKunde(0);
    this.txtNavn.Text = k.Navn;
    this.txtCpr.Text = "" + k.CPR;
    this.txtAdresse.Text = k.Adresse;
    this.txtPostnr.Text = "" + k.PostNr;
    this.txtBy.Text = session.GetBy(k.PostNr);
    this.txtTelefon.Text = "" + k.Telefon;
    this.txtMobil.Text = "" + k.Mobil;
    this.txtEmail.Text = k.Email;
    this.chkHarBoern.Checked = k.HarBoern;

    if (k.CivilStatus == 1)
      this.rdoStatusGift.Checked = true;
    else if (k.CivilStatus == 2)
      this.rdoStatusSamlever.Checked = true;
    else if (k.CivilStatus == 3)
      this.rdoStatusEnlig.Checked = true;
    else
      this.rdoStatusAndet.Checked = true;
  }
}

public class KundeKontrol
{
  public void getEvent(object sender)
  {
    if (SenderRdo.Name == "rdoPerson1" && kundeForm.rdoPerson1.Checked)
    {
      if (session.GetKundeKontainer().GetAntalKunder() >= 1)
      {
        kundeForm.VisKunde(k);
      }
    }
  }
}
\end{lstlisting}

\begin{figure}
\includegraphics{Billeder/MVC.jpg}
\caption{MVC diagram.}
\end{figure}

Når brugeren trykker på en knap på skærmen, sender view et eventobjekt videre til kontrollaget, som får modellaget til at udføre forretningslogikken. Når modellaget så er færdig giver kontrol laget besked til view om at den skal opdatere sine data.

Et af de problemer vi har haft med MVC, går ud på at placere ansvar mellem kontrollaget og viewlaget. Det er som sagt view der står for at formatere og præsentere data, og det er kontrollaget der bestemmer hvad der skal vises når det kommer til knapper og andre elementer på skærmen. Man kan sige at view bestemmer hvordan data vises og kontrollaget bestemmer hvornår data vises og hvilke data der vises. Denne balance kan dog gradbøjes og vi oplevede situationer hvor man kunne diskutere hvor det er mest hensigtsmæssigt at placere disse ansvarsområder, alt efter hvilken kode vi stod med. 

Det er også kontrollagets ansvar at fortælle modellaget at den skal ændre sig, men det kan til tider være svært udelukkende at holde sig til brugen af kontrol laget. Dette gælder specielt når view skal præsentere noget som er dynamisk og et element på skærmen har betydninger for et andet element. Det betyder at view skal bruge data, som view kun kan få ved at bede modellaget om at lave beregninger. Da vi startede med at kode MVC var vores intention at view kun skulle tilgå modellen med 'get' metoder. Vi har så senere være nød til at ændre denne opfattelse, i retning af at view også må bede modellen om at lave beregninger. Det er dog stadigt kun kontrol som må bede modellen om at ændre sig. Hele denne diskussion bunder i disciplin, og jo mere disciplineret og konsekvent vi koder systemet des nemmere bliver koden at gennemskue, både for os og for andre udviklere.

Til emnet om design patterns og specielt til MVC har vi gjort brug af følgende kilder: \cite{msdnMVC}, \cite{MVC_in_.NET} og \cite{Smalltalk-80}.

\subsection{Singleton\label{singleton}}
Singleton er et andet design pattern som vi, i modularitetens navn, kan gøre brug af. Ideen med dette pattern er at uanset hvor mange gange man instantierer et objekt, som er kodet som en singleton, så bliver der i memory kun oprettet et objekt ad gangen. Database-tilgangen er en oplagt klasse at implementere som singelton. En fordel ved dette pattern er at der ikke bliver brugt nær så meget tid på at oprette objekter på heapen.\\

Det kunne se sådan her ud.
\lstset{language=[Sharp]C, % fortæller hvilket sprog koden er skrevet i [dialekt].
  basicstyle=\small, breaklines=true}

\begin{lstlisting}
Class DBAccess{        
  private static DBAccess dbInstance;
  public static DBAccess GetDBInstance()
  {
    if (dbInstance == null)
      dbInstance = new DBAccess();
    return dbInstance;
  }

  private DBAccess()
  {
    string stiTilDB = "C:/Documents and Settings/ideas/Skrivebord/HovedOpgave/Test/Accesstestdb/testdb.mdb";
    string ConnString = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" + stiTilDB;
    myConnection = new OleDbConnection(ConnString);
    myConnection.Open();
  }
}

public static void main(String[] args)
{
  DBAccess.getDBInstance().Udfør et eller andet();
}
\end{lstlisting}

Ved at gøre konstruktøren privat forhindrer vi, at der kan oprettes flere objekter af typen DBAccess. Dermed er man tvunget til at bruge metoden GetDBInstance som, via if-sætningen, sikrer at der til enhver tid kun eksisterer ét DBAccess objekt.

%Kilder: http://msdn.microsoft.com/library/en-us/dnpatterns/desmvc.aspx
%http://www.marcclifton.com/Articles/DeclarativeProgramming/MVCPatternandDataBinding/tabid/96/Default.aspx
%http://www.c-sharpcorner.com/Code/2003/Feb/MVCDesign.asp
%http://st-www.cs.uiuc.edu/users/smarch/st-docs/mvc.html